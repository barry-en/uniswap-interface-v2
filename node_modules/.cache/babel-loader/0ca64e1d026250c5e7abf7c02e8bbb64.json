{"ast":null,"code":"import { ChainId, Token } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { DEFAULT_TOKEN_LIST_URL } from '../../constants';\n\n/**\n * Token instances created from token info.\n */\nexport class WrappedTokenInfo extends Token {\n  constructor(tokenInfo) {\n    super(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name);\n    this.tokenInfo = void 0;\n    this.tokenInfo = tokenInfo;\n  }\n\n  get logoURI() {\n    return this.tokenInfo.logoURI;\n  }\n\n}\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST = {\n  [ChainId.KOVAN]: {},\n  [ChainId.RINKEBY]: {},\n  [ChainId.ROPSTEN]: {},\n  [ChainId.GÖRLI]: {},\n  [ChainId.MAINNET]: {}\n};\nconst listCache = 'WeakMap' in window ? new WeakMap() : null;\nexport function listToTokenMap(list) {\n  const result = listCache === null || listCache === void 0 ? void 0 : listCache.get(list);\n  if (result) return result;\n  const map = list.tokens.reduce((tokenMap, tokenInfo) => {\n    const token = new WrappedTokenInfo(tokenInfo);\n    if (tokenMap[token.chainId][token.address] !== undefined) throw Error('Duplicate tokens.');\n    return { ...tokenMap,\n      [token.chainId]: { ...tokenMap[token.chainId],\n        [token.address]: token\n      }\n    };\n  }, { ...EMPTY_LIST\n  });\n  listCache === null || listCache === void 0 ? void 0 : listCache.set(list, map);\n  return map;\n}\nexport function useTokenList(url) {\n  const lists = useSelector(state => state.lists.byUrl);\n  return useMemo(() => {\n    var _lists$url;\n\n    const current = (_lists$url = lists[url]) === null || _lists$url === void 0 ? void 0 : _lists$url.current;\n    if (!current) return EMPTY_LIST;\n    return listToTokenMap(current);\n  }, [lists, url]);\n}\nexport function useDefaultTokenList() {\n  return useTokenList(DEFAULT_TOKEN_LIST_URL);\n} // returns all downloaded current lists\n\nexport function useAllLists() {\n  const lists = useSelector(state => state.lists.byUrl);\n  return useMemo(() => Object.keys(lists).map(url => lists[url].current).filter(l => Boolean(l)), [lists]);\n}","map":{"version":3,"sources":["/Users/barry.liu/go/src/uniswap/uniswap-interface-v2/src/state/lists/hooks.ts"],"names":["ChainId","Token","useMemo","useSelector","DEFAULT_TOKEN_LIST_URL","WrappedTokenInfo","constructor","tokenInfo","chainId","address","decimals","symbol","name","logoURI","EMPTY_LIST","KOVAN","RINKEBY","ROPSTEN","GÖRLI","MAINNET","listCache","window","WeakMap","listToTokenMap","list","result","get","map","tokens","reduce","tokenMap","token","undefined","Error","set","useTokenList","url","lists","state","byUrl","current","useDefaultTokenList","useAllLists","Object","keys","filter","l","Boolean"],"mappings":"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","sourcesContent":["import { ChainId, Token } from '@uniswap/sdk'\nimport { TokenInfo, TokenList } from '@uniswap/token-lists'\nimport { useMemo } from 'react'\nimport { useSelector } from 'react-redux'\nimport { DEFAULT_TOKEN_LIST_URL } from '../../constants'\nimport { AppState } from '../index'\n\n/**\n * Token instances created from token info.\n */\nexport class WrappedTokenInfo extends Token {\n  public readonly tokenInfo: TokenInfo\n  constructor(tokenInfo: TokenInfo) {\n    super(tokenInfo.chainId, tokenInfo.address, tokenInfo.decimals, tokenInfo.symbol, tokenInfo.name)\n    this.tokenInfo = tokenInfo\n  }\n  public get logoURI(): string | undefined {\n    return this.tokenInfo.logoURI\n  }\n}\n\nexport type TokenAddressMap = Readonly<{ [chainId in ChainId]: Readonly<{ [tokenAddress: string]: WrappedTokenInfo }> }>\n\n/**\n * An empty result, useful as a default.\n */\nconst EMPTY_LIST: TokenAddressMap = {\n  [ChainId.KOVAN]: {},\n  [ChainId.RINKEBY]: {},\n  [ChainId.ROPSTEN]: {},\n  [ChainId.GÖRLI]: {},\n  [ChainId.MAINNET]: {}\n}\n\nconst listCache: WeakMap<TokenList, TokenAddressMap> | null =\n  'WeakMap' in window ? new WeakMap<TokenList, TokenAddressMap>() : null\n\nexport function listToTokenMap(list: TokenList): TokenAddressMap {\n  const result = listCache?.get(list)\n  if (result) return result\n\n  const map = list.tokens.reduce<TokenAddressMap>(\n    (tokenMap, tokenInfo) => {\n      const token = new WrappedTokenInfo(tokenInfo)\n      if (tokenMap[token.chainId][token.address] !== undefined) throw Error('Duplicate tokens.')\n      return {\n        ...tokenMap,\n        [token.chainId]: {\n          ...tokenMap[token.chainId],\n          [token.address]: token\n        }\n      }\n    },\n    { ...EMPTY_LIST }\n  )\n  listCache?.set(list, map)\n  return map\n}\n\nexport function useTokenList(url: string): TokenAddressMap {\n  const lists = useSelector<AppState, AppState['lists']['byUrl']>(state => state.lists.byUrl)\n  return useMemo(() => {\n    const current = lists[url]?.current\n    if (!current) return EMPTY_LIST\n    return listToTokenMap(current)\n  }, [lists, url])\n}\n\nexport function useDefaultTokenList(): TokenAddressMap {\n  return useTokenList(DEFAULT_TOKEN_LIST_URL)\n}\n\n// returns all downloaded current lists\nexport function useAllLists(): TokenList[] {\n  const lists = useSelector<AppState, AppState['lists']['byUrl']>(state => state.lists.byUrl)\n\n  return useMemo(\n    () =>\n      Object.keys(lists)\n        .map(url => lists[url].current)\n        .filter((l): l is TokenList => Boolean(l)),\n    [lists]\n  )\n}\n"]},"metadata":{},"sourceType":"module"}